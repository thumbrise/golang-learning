# TODO: Array Package (низкоуровневый компонент, как встроенный массив)

## Базовая работа с памятью
- [ ] Сделать интерфейс Allocator (методы Malloc и Free)
- [ ] Сделать реализацию CAllocator (текущая через malloc/free)
- [ ] Выделить аллокатор в отдельное поле структуры Array
- [ ] Добавить параметр аллокатора в NewArray
- [ ] Сделать метод Reset для обнуления памяти (заполнение нулями)
- [ ] Сделать метод RawBytes для доступа к памяти как []byte (осторожно!)

## Конкурентность
- [ ] Сделать обёртку SyncArray — массив с мьютексом и методами Lock/Unlock
- [ ] Добавить методы LockedGet/LockedSet для работы уже под блокировкой (для композиции)

## Тестирование
- [ ] Написать тесты на утечки памяти с разными аллокаторами
- [ ] Проверить корректность выравнивания для сложных типов

---

# TODO: Slice Package (высокоуровневая динамическая коллекция)

## Поля структуры Slice
- [ ] Хранить указатель на Array (низкоуровневый массив)
- [ ] Хранить len (текущая длина) и cap (ёмкость)

## Конструкторы
- [ ] Сделать NewSlice с заданными len и cap (выделяет Array через аллокатор)
- [ ] Сделать MakeSlice аналогично make([]T, len, cap)
- [ ] Сделать SliceFromArray для создания слайса из готового массива

## Базовые методы (аналоги встроенного слайса)
- [ ] Сделать метод Get(index) T
- [ ] Сделать метод Set(index, value)
- [ ] Сделать метод Len() int
- [ ] Сделать метод Cap() int
- [ ] Сделать метод Append(value) — с автоматическим расширением при необходимости
- [ ] Сделать метод AppendMany(values ...T)
- [ ] Сделать метод SubSlice(start, end) *Slice — новый слайс на том же массиве (изменение len/cap)
- [ ] Сделать метод Copy() *Slice — глубокое копирование (новый массив)
- [ ] Сделать метод Resize(newLen, newCap) — изменение len/cap с переаллокацией если нужно
- [ ] Сделать метод Clear() — обнуление len (память не освобождается, можно переиспользовать)
- [ ] Сделать метод Free() — освобождение массива (вызов Clear у Array)

## Операции вставки/удаления
- [ ] Сделать метод Insert(index, value T) — со сдвигом элементов
- [ ] Сделать метод Remove(index) — со сдвигом
- [ ] Сделать метод PushFront(value) / PopFront()
- [ ] Сделать метод PushBack(value) / PopBack() (аналог Append/Remove последнего)

## Функциональные методы
- [ ] Сделать метод ForEach(f func(T))
- [ ] Сделать метод Map(f func(T) T) *Slice
- [ ] Сделать метод Filter(f func(T) bool) *Slice
- [ ] Сделать метод Reduce(initial T, f func(acc T, elem T) T) T
- [ ] Сделать метод IndexOf(value) int
- [ ] Сделать метод Contains(value) bool
- [ ] Сделать метод Reverse()
- [ ] Сделать метод Sort(less func(a, b T) bool) — реализация quicksort или интерфейса sort.Interface

## Итераторы
- [ ] Сделать ручной итератор с курсором (Next, Value, Reset)
- [ ] Сделать метод Iter() <-chan T (канал для range)

## Сериализация
- [ ] Сделать метод WriteTo(w io.Writer) error
- [ ] Сделать метод ReadFrom(r io.Reader) error
- [ ] Добавить поддержку JSON (MarshalJSON/UnmarshalJSON) через рефлексию

## Конкурентность
- [ ] Сделать обёртку SyncSlice — слайс с мьютексом (композиция Slice и sync.RWMutex)

## Тестирование
- [ ] Написать тесты на все операции (граничные случаи, расширение, вставка/удаление)
- [ ] Фаззинг-тесты со случайными последовательностями операций
- [ ] Бенчмарки против нативных слайсов (чтение, запись, append, итерация)
- [ ] Тесты на утечки памяти через аллокатор

## Документация
- [ ] Дописать примеры использования в example_test.go для всех ключевых методов
- [ ] Добавить комментарии с предупреждениями (например, что Slice не потокобезопасен, использовать SyncSlice)