# TODO: Улучшения планировщика (planner)

## 1. Оценка селективности (сколько строк вернёт условие)

### 1.1. NDV (Number of Distinct Values)
- Для поля хранить количество уникальных значений.
- Если условие равенства: `rows = total_rows / NDV` (грубая оценка).
- NDV можно обновлять при вставках/удалениях (приближённо).

### 1.2. HyperLogLog (HLL)
- Вероятностная структура для оценки количества уникальных значений.
- Занимает фиксированную память (например, 1.5 КБ для точности ~2%).
- Позволяет быстро получать NDV без точного подсчёта.

### 1.3. Count-Min Sketch (CMS)
- Оценка частоты конкретных значений (например, сколько раз встречается значение 'john@mail.com').
- Пригодится для неравномерных распределений.
- Позволяет отвечать: "сколько примерно строк будет для данного значения".

### 1.4. Гистограммы (Histograms)
- Для числовых полей или дат: хранить границы и частоты.
- Для диапазонных условий (>, <, BETWEEN) можно оценить количество строк, попавших в интервал.
- Типы: равномерные, высокие (частотные), сбалансированные по высоте.

## 2. Модель стоимости (Cost Model)

### 2.1. Базовые коэффициенты
- `COST_INDEX_ACCESS` – стоимость одного обращения к индексу (зависит от типа: Hash, BTree, GIN…).
- `COST_HEAP_ACCESS` – стоимость чтения одной записи из основной таблицы (heap).
- `COST_COMPARE` – стоимость сравнения значений (может зависеть от типа).

### 2.2. Формула стоимости для одного индекса
```
cost = (index_access_cost) * (index_lookup_complexity) * (estimated_rows) + (heap_access_cost) * (estimated_rows)
```
- `index_lookup_complexity`: 
  - Hash: O(1) → множитель 1
  - BTree: O(log N) → множитель log(rows) / log(2)
  - Full scan: O(N) → множитель total_rows (но если используется индекс, это не full scan)

### 2.3. Учёт покрытия (covering index)
- Если индекс содержит все поля, нужные для запроса (включая SELECT), обращение к heap не требуется → `heap_access_cost` умножаем на 0.

### 2.4. Комбинация нескольких условий
- Если индекс составной и покрывает несколько полей, стоимость может быть ниже, чем использование двух разных индексов.
- Если условия объединены через AND, можно использовать пересечение результатов (bitmap).
- Оценка пересечения: `rows_intersection = rows1 * rows2 / total_rows` (при независимости).

## 3. Статистика в индексе

Методы `SizeBytes()`, `Depth()`, `Stats()` должны отдавать полезную информацию для планировщика:
- `SizeBytes()` – для оценки влияния на кэш.
- `Depth()` – для BTree: прямое число обращений к узлам.
- `Stats()` – может возвращать карту с:
  - `"ndv"`: количество уникальных значений
  - `"total_rows"`: количество записей в индексе (должно совпадать с таблицей)
  - `"avg_selectivity"`: средняя селективность (1/ndv)
  - `"histogram"`: для диапазонных запросов

## 4. Планировщик (Planner)

### 4.1. Логика выбора
1. Получить список условий `[]Condition`.
2. Для каждого индекса:
   - Проверить, подходит ли он для каких-либо условий (совпадение поля, поддержка оператора).
   - Если подходит, оценить стоимость использования.
   - Если индекс составной и покрывает несколько условий, учесть это.
3. Выбрать индекс с минимальной стоимостью.
4. Если ни один индекс не подходит, вернуть `nil` (будет использован full scan).

### 4.2. Простейшая реализация (сейчас)
- Возвращает первый индекс (или nil).
- Можно сделать заглушку: выбирать индекс, который первым подошёл.

### 4.3. Эволюция
- Версия 1: Выбор по минимальной глубине (или по размеру).
- Версия 2: Учёт NDV (чем меньше строк ожидается, тем лучше).
- Версия 3: Полноценная стоимостная модель с коэффициентами.

## 5. Тестирование планировщика

- Написать бенчмарки с разными типами данных, разными распределениями.
- Сравнивать предсказанную стоимость с реальным временем выполнения (использовать `testing.B`).
- Автоматически подбирать коэффициенты (линейная регрессия или просто подбор).

## 6. Дополнительные структуры для оценки

- **Bloom filter** – быстро проверять отсутствие значения (для условий "не равно").
- **Bitmap indexes** – для полей с небольшим количеством уникальных значений (пол, статус).

## 7. Ссылки для изучения

- [HyperLogLog: алгоритм](https://en.wikipedia.org/wiki/HyperLogLog)
- [Count-Min Sketch](https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch)
- [PostgreSQL Statistics](https://www.postgresql.org/docs/current/planner-stats.html)
- [Database System Concepts (Silberschatz)](https://www.db-book.com/)

---

Пока можно оставить простую заглушку, но держать в уме эти идеи для постепенного улучшения.
