**Вопрос по highload-проектированию:**

## Собеседующий

Представь, что мы разрабатываем систему голосования за комментарии, похожую на Reddit или LeetCode. Пользователи могут ставить лайки и дизлайки комментариям. Требования:

- Отображать текущий рейтинг комментария (сумма лайков и дизлайков) в реальном времени.
- Обрабатывать высокую нагрузку: миллионы пользователей, тысячи комментариев в секунду.
- Один пользователь может голосовать только один раз за комментарий (может изменить свой голос).
- Обеспечить низкую задержку при чтении рейтинга.
- Система должна быть отказоустойчивой и масштабируемой.

Опиши архитектуру решения: выбор базы данных (или комбинации), схему хранения данных, механизмы кеширования, обработку конкурентных голосований, балансировку нагрузки и шардирование. Также расскажи, как бы ты обеспечил консистентность данных при параллельных запросах. Можешь начать с высокоуровневой схемы, а затем углубиться в детали.

## Я

Приложение с точки зрения инфраструктуры будет состоять из следующих наборов сервисов

Внешний мир:
- api_gateway

Интеграционные сервисы:
- observability
  - logs_elk
  - traces_jaeger
  - metrics_prometheus
  - profiles_pyroscope
  - dashboard_grafana
- analytics_clickhouse
- event_bus_kafka

Сервисы повторяющиеся для каждого уникального API:
- balancer_haproxy
- postgresql (если есть)
  - gateway_pgpool2 
  - process_manager_pgbouncer (для каждого инстанса postgres)
- redis (если есть)
  - redis_cluster - Не просто redis sentinel, потому что нужно горизонтальное масштабирование пропускной способности

Общий флоу:
- Фронтенд отправляет запрос на адрес апи шлюза. В данном случае именно фронтенд, но обычно и сервисы общаются друг с другом не напрямую, а через балансировщики сервисов при синхронном взаимодействии и через балансировщик событийной шины при асинхронном взаимодействии
- Апи шлюз применяет правила маршрутизации, авторизует запрос, добавляет open telemetry заголовки и делает всю остальную работу. Потом направляет запрос к нужному балансировщику
- Балансировщик определенного сервиса направляет запрос к инстансу приложения


Сервис комментариев:
- backend_go
- cache_redis
- oltp_postgresql

---

## Собеседующий

Теперь перейдём к деталям реализации бекенда для сервиса голосования. 
Расскажи, как ты спроектируешь хранение данных (схему БД, использование Redis), как будешь обрабатывать конкурентные голосования, обеспечивать консистентность и низкую задержку. 
Можешь начинать с любого аспекта, но постарайся покрыть все ключевые моменты: схема таблиц, кэширование, обработка запросов, гарантии целостности, масштабирование.


## Я

### Общая логика

- Проверить валидность подписи jwt и задекодить юзера
- Автоматически применить логику обсервабилити в мидлвейр
- Логировать происходящее, 
- Применять семплирование, если используется tail sampling

### Юзкейсы

#### Пользователь сохраняет комментарий

**_api_**

POST /api/comments

Параметры:
- jwt
- commentable_id
- content

Алгоритм:
- Генерируем UUID для комментария
- Записать комментарий в кеш
  - Накладно выдерживать миллионы операций записи в OTLP
  - Применяем паттерн батч сохранения
  - Сохраняем в кеш, он должен быть персистентным, то есть иметь rdb и WAL для восстановления в случае сбоя
  - Для того чтобы воркеры могли правильно обрабатывать комментарии мы должны не просто сохранить в кеш комментарий
    - Для оптимального хранения, чтения, обработки, можем добавить несколько индексов
    - ZSET
- Если получили ОК от кеша, возвращаем uuid и created_at

Горизонтальная Масштабируемость:
- Зависит от количества апи узлов, могут работать независимо друг с другом
- Зависят только от шлюза к редису

**_persist_worker_**

Алгоритм:
- По условию, например каждые n времени запускаем батч персист
- Получаем из кеша пачку необработанных комментариев
  - Размер пачки конфигурируемый или вычисляемый
