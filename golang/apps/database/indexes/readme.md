# Индексы в PostgreSQL

Набор заметок для тех, кто хочет понимать, что происходит под капотом, и уметь выбирать правильный инструмент. Ориентировано на бекенд-разработчиков с опытом работы с Go и PostgreSQL.

## 1. Хеш-индекс (Hash)

Хранит пары «хеш ключа → ссылка на строку (ctid)». В PostgreSQL до 10 версии был ненадёжным (не участвовал в WAL), сейчас полноценный, но с нюансами.

**Применимость**
- Только равенство (`=`).
- Бесполезен для диапазонов, сортировки, `IS NULL`.

**Плюсы**
- Константное время поиска в среднем (O(1) с учётом коллизий).
- Очень компактен (если ключи короткие).

**Минусы**
- Не упорядочен — нельзя использовать для `ORDER BY` или `BETWEEN`.
- Коллизии замедляют поиск (разрешаются цепочками).
- Не поддерживает уникальность напрямую (можно создать уникальный индекс, но он останется хеш-индексом).

**Пример создания**
CREATE INDEX idx_name ON table USING hash (col);

Рекомендуется только при миллионах точечных запросов и полном отсутствии диапазонных.

---

## 2. B-Tree (на самом деле B+Tree)

Стандартный индекс по умолчанию. В PostgreSQL реализован как **B+Tree**: данные хранятся только в листовых страницах, листья связаны в двусвязный список, внутренние узлы содержат только ключи-навигаторы. Это даёт максимальную производительность при поиске по диапазону.

### B-Tree против B+Tree

| Характеристика | Классическое B-дерево | B+дерево (Postgres) |
|----------------|------------------------|----------------------|
| Где данные? | В любых узлах | Только в листьях |
| Связь листьев | Нет | Двусвязный список |
| Диапазонный поиск | Тяжело (скачки по дереву) | Очень быстро (по списку) |
| Высота дерева | Выше (меньше ключей в узле) | Ниже (больше ключей в узле) |
| Поиск по ключу | Может завершиться раньше | Всегда идёт до листа |

**Применимость**
- Любые сравнения: `=`, `>`, `<`, `>=`, `<=`, `BETWEEN`.
- `ORDER BY`, `GROUP BY`, уникальность, `IS NULL`.
- Частичное сканирование (prefix search) для текстовых полей.

**Плюсы**
- Минимум I/O: высота 3–4 при миллионах записей.
- Данные всегда отсортированы.
- Поддерживает уникальные ограничения.
- Можно строить покрывающие индексы (`INCLUDE`).

**Минусы**
- Некоторый оверхед на вставку/удаление (расщепление страниц).
- Занимает больше места, чем хеш.
- Требует обслуживания (autovacuum).

**Пример**
CREATE INDEX idx_name ON table USING btree (col);

---

## 3. GIN (Generalized Inverted Index)

Инвертированный индекс: для каждого элемента составного значения (слова в тексте, элемента массива, ключа JSONB) хранится список ссылок на строки. Внутри использует B-дерево для поиска элементов.

**Применимость**
- **Массивы**: операции `@>`, `&&`, `?`.
- **Полнотекст**: `tsvector` / `@@`.
- **JSONB**: поиск по ключам/значениям (`?`, `@>`, `->>`).
- **Триграммы** (pg_trgm) для `LIKE '%...%'`.

**Плюсы**
- Единственный способ эффективно искать внутри составных типов.
- Быстрый поиск элементов (логарифмический поиск по элементу, затем чтение списка).

**Минусы**
- Медленная запись: при вставке строки нужно обновить списки для каждого элемента.
- Много места (особенно для полнотекста).
- Требует периодической очистки (vacuum).
- Сам индекс не хранит данные строк, только ссылки.

### Особенность: `fastupdate` и Pending List

По умолчанию `fastupdate = ON`. Новые записи не пишутся сразу в основной индекс, а попадают в специальную очередь — **pending list**. Это делает вставку очень быстрой, но замедляет чтение (приходится проверять pending list). При достижении лимита (`gin_pending_list_limit`) или во время `VACUUM` данные из очереди пачками сливаются в основной индекс.

- `fastupdate = ON` — оптимально для **write-heavy** нагрузок.
- `fastupdate = OFF` — для **read-heavy**, когда важна каждая миллисекунда на поиске.

**Пример**
CREATE INDEX idx_name ON table USING gin (col) WITH (fastupdate = on);

---

## 4. BRIN (Block Range Index)

Индекс по диапазонам блоков. Для каждого набора страниц (обычно 128 блоков) хранит минимальное и максимальное значение колонки. Идеален для очень больших таблиц с коррелированным порядком данных (логи, временные ряды, автоинкремент).

**Применимость**
- Гигантские таблицы (миллиарды строк), где B-Tree уже не влезает в память или слишком дорог.
- Поля, значения которых возрастают вместе с физическим положением строк (timestamp, serial).
- Запросы, выбирающие большие диапазоны («данные за последний час»).
- Там, где важна экономия места (BRIN занимает килобайты против гигабайт у B-Tree).

**Плюсы**
- Колоссальная компактность: в тысячи раз меньше B-Tree.
- Очень быстрое сканирование больших диапазонов (последовательное чтение блоков).
- Не требует частого обновления при вставках (если данные добавляются в конец).

**Минусы**
- Не подходит для точечного поиска — придётся сканировать целый диапазон блоков.
- Эффективность падает, если данные вставляются вразнобой.
- Может возвращать ложные срабатывания (нужно перепроверять по таблице).

**Пример**
CREATE INDEX idx_name ON table USING brin (col) WITH (pages_per_range = 128);
`pages_per_range` управляет точностью/размером.

---

## 5. Параллельные планы (Parallel Scans)

PostgreSQL умеет распараллеливать выполнение запросов на несколько ядер. Для этого планировщик строит **partial plan**, который выполняется в воркерах, а затем результаты собираются узлом `Gather` или `Gather Merge`.

### Виды параллельных сканов

- **Parallel Sequential Scan** — таблица делится на диапазоны блоков, каждый воркер сканирует свой диапазон.
- **Parallel Index Scan** — только для B-Tree. Воркеры «дерутся» за листовые страницы индекса.
- **Parallel Bitmap Heap Scan** — лидер строит общую битовую карту, воркеры читают страницы по кускам.
- **Parallel Append** — параллельное выполнение дочерних планов (например, для партицированных таблиц).
- **Parallel Aggregation** — двухстадийная агрегация: сначала частичная в воркерах, потом финальная в лидере.
- **Parallel Hash Join** — общая хеш-таблица строится всеми воркерами, затем большой таблица джойнится параллельно.

### Настройка

Основные параметры: `parallel_workers`, `max_parallel_workers_per_gather`, `parallel_setup_cost`, `parallel_tuple_cost`.

---

## 6. Частичные индексы (Partial Indexes)

Индекс, который содержит только часть строк таблицы, удовлетворяющих условию `WHERE`.

CREATE INDEX idx_orders_paid ON orders (created_at) WHERE status = 'paid';

Такой индекс будет:
- **В сотни раз меньше** полного индекса.
- **Быстрее** при сканировании.
- **Меньше нагружать запись**, так как обновляется только при изменении статуса на `'paid'`.

**Важно:** Условие запроса должно логически подразумевать условие индекса. Для `SELECT ... WHERE status = 'paid' AND created_at > ...` индекс применится. Для `status = 'cancelled'` — нет.

**Применение в Go-проектах**
- Софт-делет: `WHERE deleted_at IS NULL`.
- Статусные модели: только активные заказы, только админы и т.п.
- Мультитенантность с изоляцией по региону.

---

## 7. B-link-Tree: братская помощь при конкурентном доступе

В классическом B-Tree при разделении узла (split) возникает блокировка, которая может заставить другие процессы ждать. **B-link-Tree** решает это добавлением в каждый узел указателя на **правого брата** (right-link). При разделении новый узел создаётся справа, указатели обновляются, а родитель обновляется позже. Читатель, попавший в старый узел и не найдя ключ, просто переходит к брату — блокировки не нужны.

**Итог:** конкуренция снижается за счёт братской взаимопомощи, а не за счёт блокировок.

---

## Шпаргалка по выбору индекса

| Задача | Тип индекса |
|--------|-------------|
| Точечные `=` (email, id) | **Hash** (если нет диапазонов) или **B-Tree** |
| Диапазоны, сортировка, любые сравнения | **B-Tree** |
| Полнотекст, массивы, JSONB | **GIN** |
| Огромная таблица с монотонным полем (логи по дате) | **BRIN** |
| Хочу покрыть запрос без обращения к таблице | **B-Tree** с нужными колонками (или `INCLUDE`) |
| Очень много вставок и поиск по элементам (JSONB) | **GIN** с осторожностью, `fastupdate` включён |